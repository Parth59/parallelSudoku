Kevin Kuan (kkuan)

Checkpoint:

Work completed so far:March 30 – April 2: Finished the proposal
April 3 – 11: Began researching different ways to implement a serial implementation, began my attempt at an implementation
April 12 – 16: Begin work on a parallel implementation of the Sudoku solver. Finishing up a serial implementation, have not started on a parallel implementation
April 17 – 21: Continue to work on the parallel implementation. Finished a working serial implementation, have not started on the parallel implementation	New project schedule:March 30 – April 2: Research and write a proposal for a project
April 3 – 11: Research various algorithms for a serial implementation, begin implementing the serial implementation
April 12 – 16: Continue to work on the serial implementation 
April 17 – 21: Finish working on the serial implementation, begin to collect data on the algorithm for different processors
April 22 – April 25: Finish gathering data for serial implementation, begin working on the parallel implementation
April 26 - 30: Continue working on the parallel implementation
May 1 – May 4: Finish the parallel implementation, clean up code in anticipation for gathering data
May 5 - 11: Collect data on the parallel algorithm for different processors. Finish the final project report.
SummaryTo reiterate, my goal is to write both a serial and parallel Sudoku solver, then run the program on different processors to compare the speedup times between my serial and parallel implementation. After some research, I determined that a backtracking serial implementation is the most reasonable algorithm to implement for the sake of having a working solver that could be parallelized. In my current serial implementation, I utilize backtracking in order to permute all of the possible Sudoku board states, and then narrow down the boards until I find my solution. This will make it trivial to parallelize because my optimization will focus on creating every board permutation from different starting locations. However, I have not begun doing initial time tests on different processors for this serial implementation. At the moment, I am more focused on making sure this serial implementation cannot be optimized anymore, and I would also like to write a more clean method of testing different boards, as my current implementation of testing makes it difficult to efficiently try different Sudoku boards. Once I finish cleaning up the serial implementation and gather data on the speedup for the serial implementation, I will begin writing the parallelized implementation.ProgressWith respect to the goals and deliverables stated in my proposal, I have a working serial implementation of my Sudoku solver. I have not had time to clean up my test cases so that it will make it easier to record the timings, but I have tested it on multiple boards of varying difficult and it will eventually solve the board, even if it may be slow on extremely difficult boards.However, I do not think I can reach my stretch goal of implementing multiple serial/parallel implementations, as I’ve now realized that it makes a lot more sense to focus on one efficient serial/parallel implementation rather than many average serial/parallel implementations. I want to refocus my attention on comparing the differences between a serial and parallel implementation of the solver, so I want to devote more time towards optimizing one implementation than making many of them. But once again, this was only a “nice to have” goal, so I will not prioritize my attention towards getting to this goal, but rather heavily consider coming back to this goal if I somehow happen to have time. This reasoning also applies to my “nice to have” goal of extending my algorithm for boards bigger than 9x9. Plan to show at the parallelism competitionI intend to show graphs and tables of the speedup differences between the serial and parallel implementation. I don’t think it makes a lot of sense to show a demo of the algorithm, as some of the more difficult boards may take longer to solve.
Preliminary ResultsUnfortunately, I currently do not have preliminary results of the speedup of the serial implementation of different processors. However, I have tested my current implementation on boards of varying difficulty, and I have confirmed that my implementation can eventually solve any kind of Sudoku board of varying difficulty.Issues/concernsThere aren’t a lot of things that are concerning to me so far in this project. I suppose the only small struggle I had was settling on a serial implementation, but once I decided to implement a backtracking solution, my work was very straightforward. I don’t think I will encounter many problems in my parallel implementation, as I am only concerned with needing time to code. However, I will be sure to visit a TA if I happen to have any concerns or ideas.

